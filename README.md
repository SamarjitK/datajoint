# datajoint

To use this web app, you will need to download (make sure you add poetry and npm to your path):

- [Python 3.9.6](https://www.python.org/downloads/release/python-396/) (there is an issue with datajoint-ssl interfacing with versions >3.10, so use newer versions at your own risk!)
- Python package manager: [Poetry](https://python-poetry.org/docs/#installation)
- Database server: [Docker](https://docs.docker.com/desktop/)
- Web app utilities: [Nodejs](https://nodejs.org/en)

Next, for the app to run smoothly, run the following commands (at the root directory):

- `mkdir databases`: this is where databases will be stored
- `poetry install`: gets all python dependencies
- `cd next-app`, `npm install`: gets all javascript dependencies, within app directory

To run the app, launch Docker Desktop, ensure you are in `/next-app`, and run:

``` npm run dev ```

You should be able to view the app at http://localhost:3000/. The terminal window will then track actions: this is useful to view the status of datajoint commands, and for debugging.

## 1. Setting up the database

![start screen](readme/select_db.png)

First, add a database that you want to work with. Each one runs independently, so you can interact with them separately. Then, click the start button to spin up your instance. Once that is done, click the connect button (link icon) to connect.

> note: this generally doesn't work the first time you start a database:

![error message](readme/select_db_error.png)

> If this is the case, first try connecting again, then stop and restart the database and try it again. On subsequent connects this shouldn't be an issue, but retrying connection a couple times always works.

Once connected, you can set a user. This is used for tagging (once that is implemented). If you don't want to type this in every time, you can set a default by changing `username: str = None` in `api/app.py` to your desired username.

## 2. Adding data

There must be at least one experiment to query, and you can come back to this screen and add more at any point. You must paste in the full path for the directories you select.

For example, if using the testbed:

- data: `/Volumes/data/datajoint_testbed/data`
- meta: `/Volumes/data/datajoint_testbed/meta`
- tags: `/Volumes/data/datajoint_testbed/data`

If using your own directories, this is what each one should consist of (make sure that each experiment shares a file name across the three directories):

- data (`*.h5`): H5 files for all single-cell experiments
- meta (`*.json`): json files for all experiments, generated by `parse_data.py`
- tags (`*.json`): json files for all experiments. If no tags added yet, set all files to `{}` (empty)

The process of adding data can take a while (around a minute per experiment). You can view the status of the process in the terminal window.

> `api/helpers/pop.py` currently has harcoded paths for `NAS_DATA_DIR` and `NAS_ANALYSIS_DIR`. If you have MEA data, make sure these paths are accurate to where you data and analysis directories are mounted.

## 3. Querying data

Finally, you can query your data. This works through a system of nested logical blocks and conditions, which should allow for practically any query.

> Sometimes, "add condition" will hang on `Loading...`. This is because it pulls fields directly from tables, and occasionally fails. This needs to be fixed, but for now simply delete it and re-add the condition until it works.

At each level, you can query on table parameters or tags (which isn't implemented yet). If you choose to query on variable parameters (json attributes), you will have to specify the data type yourself.

Querying on string values gives you additional options: like and not like. You can use `%` as a wildcard to construct broad queries. For example, to find all epoch groups where the protocol ran was some form of noise:

![%noise%](readme/query_example.png)

Make sure you click the save button for each condition in case there are unsaved changes! To confirm you query is correct, you can use the "peek at QueryObj" button to view a neatly formatted and copyable query object:

![query object, neatly formatted as a json](readme/queryobj_example.png)

In the future you'll be able to paste this in and re-run previous queries. Once you are happy with your query, click View Results to run!

## 4. Viewing results

I'm currently working on this, so things will change over time. For now, a query will return a tree of results matching your query. You can navigate it with the plus and minus icons, and use the checkbox for tagging (not implemented yet).

Additionally, the bottom-right panel shows all metadata that datajoint has for the item clicked most recently. You can use this to find more things to query on.

At the same time, the top-right panel will be used for summary visualizations of whatever object was last clicked. Currently, this only works for epochs in *single cell* experiments: it shows you the trace for the epoch's 'Amp1' response object. In the future, the visualization box will give you more options: viewing different response/stimulus objects, creating and importing your own visualizations, etc.

## 5. Exporting results

> To do!

## 6. Cleaning up

It is good practice to go back to the select database screen and stop the database you were using. If that's too much work, you can always open Docker Desktop and manually stop and/or delete any running containers later. You can only have one connection at a time, so if you allow these to accumulate you may run into issues (it will also eat up your memory!)

Finally, you can stop running the web app by navigating back to the terminal and running `Ctrl+C`.